事务
事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。在计算机术语中，事务通常就是指数据库事务。

概念
一个数据库事务通常包含对数据库进行读或写的一个操作序列。它的存在包含有以下两个目的：

1、为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
2、当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。

当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。

但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。

特性
并非任意的对数据库的操作序列都是数据库事务。事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。

原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。
一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。
隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。

举例
用一个常用的“A账户向B账号汇钱”的例子来说明如何通过数据库事务保证数据的准确性和完整性。熟悉关系型数据库事务的都知道从帐号A到帐号B需要6个操作：

1、从A账号中把余额读出来（500）。
2、对A账号做减法操作（500-100）。
3、把结果写回A账号中（400）。
4、从B账号中把余额读出来（500）。
5、对B账号做加法操作（500+100）。
6、把结果写回B账号中（600）。

原子性：
保证1-6所有过程要么都执行，要么都不执行。一旦在执行某一步骤的过程中发生问题，就需要执行回滚操作。 假如执行到第五步的时候，B账户突然不可用（比如被注销），那么之前的所有操作都应该回滚到执行事务之前的状态。

一致性
在转账之前，A和B的账户中共有500+500=1000元钱。在转账之后，A和B的账户中共有400+600=1000元。也就是说，数据的状态在执行该事务操作之后从一个状态改变到了另外一个状态。同时一致性还能保证账户余额不会变成负数等。

隔离性
在A向B转账的整个过程中，只要事务还没有提交（commit），查询A账户和B账户的时候，两个账户里面的钱的数量都不会有变化。
如果在A给B转账的同时，有另外一个事务执行了C给B转账的操作，那么当两个事务都结束的时候，B账户里面的钱应该是A转给B的钱加上C转给B的钱再加上自己原有的钱。

持久性
一旦转账成功（事务提交），两个账户的里面的钱就会真的发生变化（会把数据写入数据库做持久化保存）！

原子性与隔离行
一致性与原子性是密切相关的,原子性的破坏可能导致数据库的不一致，数据的一致性问题并不都和原子性有关。
比如刚刚的例子，在第五步的时候，对B账户做加法时只加了50元。那么该过程可以符合原子性，但是数据的一致性就出现了问题。

因此，事务的原子性与一致性缺一不可。

--------------------- 

2、锁的基本知识
数据库管理系统中采用锁的机制来管理事务，当多个事务同时修改同一数据时，只允许持有锁的事务修改该数据，其他事务只能“排队等待”，直到前一个事务释放其拥有的锁。
在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常称为读锁（Read Lock）和写锁（Write Lock）。
（1）读锁（Read Lock）
读锁（Read Lock）也称为共享锁（Shared Lock）。它是共享的，或者说是相互不阻塞的。多个客户端在同一时间可以同时读取同一资源，互不干扰。
（2）写锁（Write Lock）
写锁（Write Lock）也称为排他锁（Exclusive Lock）。它是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，这是为了确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源，保证安全。
读锁与写锁的区别：
 	
读锁（Read Lock）
写锁（Write Lock）
读锁（Read Lock）
兼容
不兼容
写锁（Write Lock）
不兼容
不兼容
3、死锁的概念与避免
死锁，即当两个或多个处于不同序列的用户打算同时更新某相同的数据库时，因相互等待对方释放权限而导致双方一直处于等待状态。在实际应用中，两个不同序列的客户打算同时对数据执行操作，极有可能产生死锁。更具体的讲，当两个事务相互等待操作对方释放的所持有的资源，而导致两个事物都无法操作对方持有的资源，这样无期限的等待被称为死锁。
不过，MySQL的InnoDB表处理程序具有检查死锁这一功能，如果该处理程序发现用户在操作过程中产生死锁，该处理程序立刻通过撤销操作来撤销其中一个事物，以便使死锁消失。这样就可以使另外一个事务获取对方所占有的资源而执行逻辑操作。
4、事务的隔离级别
（1）Serializable（串行化）
采用此隔离级别，一个事物在执行过程中首先将其欲操纵的数据锁定，待事务结束后释放。如果此时另一个事务也要操纵该数据，必须等待前一个事务释放锁定后才能继续进行。两个事物实际上是以串行化方式运行的。
（2）Repeatable Read（可重复读）
采用此隔离级别，一个事物在执行过程中能够看到其他事务已经提交的新插入记录，看不到其他事务对已有记录的修改。
（3）Read Committed（读已提交数据）
采用此隔离级别，一个事物在执行过程中能够看到其他事务已经提交的新插入记录，也能看到其他事务已经提交的对已有记录的修改。
（4）Read Uncommitted（读未提交数据）
采用此隔离级别，一个事物在执行过程中能够看到其他事务未提交的新插入记录，也能看到其他事务未提交的对已有记录的修改。
综上所述可以得出，并非隔离级别越高越好，对于多数应用程序，只需把隔离级别设为Read Committed即可，尽管会存在一些问题。


